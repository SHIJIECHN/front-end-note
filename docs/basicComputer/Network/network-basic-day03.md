---
autoGroup-1: 网络基础
sidebarDepth: 3
title: 3. HTTP报文、请求方式、GET与POST
---

## HTTP报文
### 1. HTTP报文前言
1. `HTTP`基于`TCP/IP`通信协议来传递数据。    
2. `HTTP`基于客户端/服务端（`C/S`）架构模型（浏览器、服务器）。    
3. 通过一个可靠的连接来交换信息，是一个无状态的请求/响应协议（没有记忆）。 
4. （传统的http请求）限制每次连接只处理一个请求与。服务器处理完客户的请求，并受到客户的应答后，断开连接。采用这种方式节省传输时间。  
5. 只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过http发送。客户端以及服务器指定使用合适的MIME-type内容类型。
6. MIME-type(Multipurpose Internet Mail Extensions type)多用途互联网邮件扩展类型。

### 2. HTTP报文定义
在客户端与服务器之间发送的数据块。这些数据块以一些文本的元信息（meta-information）开头，描述了报文的内容及含义，后面跟着可选的数据部分，这些报文在客户端、服务器和代理之间流动。所以HTTP报文的发送也叫报文流。

1. 每条HTTP报文包含一个客户端请求和服务端响应。
2. 请求报文Request和响应报文Response。


### 3. HTTP报文组成部分
1. 对报文进行描述的起始行
2. 包含属性的首部/头部（header）
3. 包含数据的主体（body）

## 请求方式
### 1. 8种请求方式
1. GET/POST
2. OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。
3. HEAD：返回与GET请求相一致的响应，响应体被返回。
4. PUT：向指定资源位置上传其最新内容（form表单不支持）。
5. DELETE：请求服务器删除Request-URI标识的资源（form表单不支持）。
6. TRACE：回显服务器收到的请求，主要用于测试或者诊断。
7. CONNECT：连接改为管道方式的代理服务器。

### 2. 常见4种
1. `put`： 上传资源，`form`表单不支持、提交即存储的原则（无验证机制，安全漏洞）、需配置服务器支持`put`方式转发给后端操作。
2. `delete`：删除资源，`form`表单不支持、提交即存储的原则（无验证机制，安全漏洞）、需配置服务器支持`delete`方式转发给后端操作。
3. `post`：修改资源。参数形式Form Data。
4. `get`：获取资源。参数形式Query String Parameters。

## GET/POST请求方式

### 1. GET/POST请求方式的作用
1. `GET`主要用于请求数据。    
2. `GET`的数据在请求体中是查询字符串参数形式（`Query String Parameters`）。    
3. `POST`主要用于传输数据到后端进行增加、删除、更新数据、提交表单。     
4. `POST`的数据在请求体中是表单数据形式（`Form Data`）。    

GET/POST：view source中仍然是url参数键值对形式 a=1&b=2

### 2. `GET/POST`请求方式的区别   
1. `POST`更安全：不会作为`url`的一部分、不会缓存、保存在服务器日志和浏览器记录中
2. `POST`发送的数据量更大（`GET`有`url`长度限制）
   - IE（2083字节） 
   - firefox(65536字符)   
   - chrome(8182字符)   
   - safari(80000字符)   
   - opera(190000字符)
3. `POST`能发送更多的数据类型，`GET`只能发送`ASCII`码字符
4. `POST`比`GET`速度慢：
   - `POST`请求包含更多的请求头
   - `POST`接受数据之前会先将请求头发送给服务器确认，然后发送数据：   
      `POST`过程：
      1. 第三次握手后，浏览器确认并发送`post`请求头
      2. 服务器返回状态码`100`后，`continue`响应
      3. 浏览器开始发送数据
      4. 服务器返回`200`响应  
  
      `GET`过程：
      1. 第三次握手后，浏览器确认并发送请求头和数据。
      2. 服务器返回`200`响应

   - `GET`会进行数据缓存，`POST`不会
    <img :src="$withBase('/basicComputer/Network/get.png')" alt="get"> 

   - `POST`不能进行管道化传输
      1. 串行连接：请求一次就连接一次，等待响应回来，断开连接。下一次请求再次连接。
      2. 持久化连接（`connection：keep-alive`）：（`HTTP/1.0`、`HTTP/1.1`）连接不会关闭。只连接一次，不需要重复连接。
      3. 管道化持久连接（`HTTP/1.1`）把所有请求放到发送队列里，不等响应，一个一个发送请求的同时接受响应的响应。

      串行传输：
      <img :src="$withBase('/basicComputer/Network/serail-connection.png')" alt="serail-connection"> 

      持久化连接：
      <img :src="$withBase('/basicComputer/Network/persistent-connection.png')" alt="persistent-connection"> 

      管道化持久连接：
      <img :src="$withBase('/basicComputer/Network/pipelined-and-lasting-connection.png')" alt="pipelined-and-lasting-connection"> 

## GET/POST请求方式中的幂等性
1. 数学中幂等：x^y = x; x = 0 || 1;

2. 幂等性：一个`HTTP`请求中，不会对数据或状态做修改，并且每次请求都会返回相同的结果。（只要获取数据，就具有幂等性） 
3. 必要性：
   - 1. `GET`请求必须遵守幂等性，从`HTTP`请求上来看，`GET`只能获取数据。
   - 2. `POST`请求一般做增删改的操作，所以一般不遵守幂等性。    


4. 管道化传输不可以用非幂等性请求的原因：  
假设：10个请求，9个成功，1个失败，那么得重新请求，所以就不能做增删改的请求。    
所以：post请求不管是幂等性还是非幂等性的请求都不能进行管道化传输的。oprea浏览器支持管道化传输之外，其他的浏览器需要服务器配置。基本上其他的浏览器都是持久化连接。




















## 关闭TCP的四次挥手
`FIN`：`finish` 关闭连接  

状态：
- `FIN-WAIT-1` 等待远程`TCP`的连接中断请求，或先前的连接中断请求的确认
- `FIN-WAIT-2` 从远程`TCP`等待连接中断请求
- `CLOSE-WAIT` 等待从本地用户发来的连接中断请求
- `LAST-ACK` 等待原来发向远程`TCP`的连接中断请求的确认
- `TIME-WAIT` 等待足够的时间以确保远程`TCP`接受到连接中断请求的确认
- `CLOSE` 没有任何连接状态

四次挥手流程：
 <img :src="$withBase('/basicComputer/Network/four-way-handshake.png')" alt="four-way-handshake"> 


1. 客户端发送连接关闭报文（此时已停止发送数据）（第一次挥手）
   - 报文头部：`FIN=1`（序列号`seq=u`）
   - 此刻：客户端进入终止等待`1`状态（`FIN-WAIT-1`）
2. 服务器接到连接关闭报文，并发送确认报文（第二次挥手）
   - 报文首部：`ACK=1 ack=u+1`（确认`FIN`）（序列号`seq=v`）
   - 此刻：服务端进入关闭等待状态（`CLOSE-WAIT`）
   - 说明：连接半关闭状态，客户端没有数据要发送，但服务器如果还要发送数据，客户端依然需要接受。
3. 客户端收到服务器的确认请求后，客户端进入终止等待`2`状态（`FIN-WAIT-2`）
   - 服务器在这期间还要确认客户端所需要的数据是否真的发送完毕了，如果还没发送完，则继续发送数据
4. 服务器确认数据已发送完毕后，向客户端发送连接关闭报文（第三个挥手），服务器进入最后确认状态（`LAST-ACK`）
    - 报文首部：`FIN=1 ACK=1 ack=u+1`（确认上一次数据包）序列号`seq=w`
5. 客户端收到服务器的连接关闭报文后，发出接受确认报文（第四次挥手），客户端进入时间等待状态（`TIME-WAIT`）
    - 报文首部：`ACK=1 ack=w+1`(确认上一次数据包) 序列号`seq=u+1`
6. 服务器收到客户端的确认，立即进入`TCP`关闭状态（`CLOSE`），`TCP`连接结束
   - `TCP`关闭，服务端要比客户端早一些

`TIME-WAIT`时长：`MSL Maximum Segment Lifetime` 最大报文生存时间。`MSL`的值根据不同情况而不同，一般是`30`秒 `1`分钟 `2`分钟。  
目的：保证客户端发送的最后一个报文能够发到服务器，一旦报文丢失，服务器会认为自己最后一次发送的`FIN+ACK`包，客户端没有收到，此时，服务器会重新发送一次`FIN+ACK`包，而客户端可以在`2MSL`的`TIME-WAIT`时间内收到重新传输的`FIN+ACK`包，接着重新进行第四次挥手，并重启`2MSL`计时器。


为什么是四次挥手？   
原因：第一次挥手的时候发送了`FIN`包，服务器接收到以后，表示客户端不再发送数据了，但还能接收数据。这时服务器先向客户端先发送确认包，并且确认自己是否还有数据没有发送给客户端，这个确认的阶段就是`CLOSE-WAIT`，所以在终止等待`2`（`CLOSE_WAIT`）的开始和结束需要各发一个包，状态开始时向客户端发送的包是确认收到来自客户端的`FIN`包，状态结束时向客户端发送的是确认数据已经完整发送，所以四次挥手。


`TCP`连接建立后，客户端突然出现故障？   
`TCP`保活计时器：客户端如果出现故障，服务器每收到一次客户端的请求后都会重新复位保活计时器，时间通常是`2`小时，若`2`小时还没有收到客户端的数据，服务器就会发送一个探测报文段，以后每隔`75`分钟发送一次。若一连发送`10`个探测报文仍无反应，服务器就认为客户端出了故障，此时将关闭连接。

## 同源策略
同源策略`Same-Origin-Policy(SOP)`   
`web`浏览器只允许在两个页面有相同的源时，第一个页面访问第二个页面里的数据。   
源（域名）：协议+域名+端口   
同源：相同的协议&&相同的域名&&相同的端口    
同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。只有同一个源的脚本赋予`dom`、读写`cookies`、`session`、`ajax`等操作的权限。   

不受同源策略限制的项：
1. 页面的超链接
2. 重定向页面
3. 表单的提交
4. 资源引入`script src`/`link href`/`img src`/`iframe src`

只要有`JS`引擎的浏览器都使用同源策略。


