---
autoGroup-2: 网络攻击
sidebarDepth: 3
title: 网络攻击
---

## XSS跨站点脚本攻击

Cross-Site Scripting（跨站脚本攻击）是一种代码注入攻击。比如注入的攻击代码为获取当前网站用户的Cookie，拿到用户的Cookie就可以执行其他操作。

XSS本质是：恶意代码未经过滤，与网站正常的代码混在一起。

### 1. 模拟XSS攻击

### 2. XSS攻击的分类

|类型|存储区|插入点|
|----|:----|:-----|
|存储型|后端数据库|HTML|
|反射性|URL|HTML|
|DOM型|后端数据库/前端存储/URL|前端JavaScript|

- 存储区：恶意代码存放的位置
- 插入点：由谁取得恶意代码，并插入到网页上

### 3. 存储型XSS

攻击步骤：
1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站**服务端**将恶意代码从数据库取出，拼接在HTML中返回给浏览器。
3. 用户浏览器接受到响应解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站，如论坛发帖、商品评论、用户私信等。

### 4. 反射型XSS

攻击步骤：
1. 攻击者构造特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL时，网站**服务端**将恶意代码从URL中取出，拼接在HTML中返回给浏览器
3. 用户浏览器接受到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

存储型XSS与反射型XSS的区别：存储型XSS的恶意代码存在数据库中，反射型XSS的恶意代码存在URL里。

这种攻击常见于通过URL传递参数的功能，如网站搜索、跳转等。

### 5. DOM型

攻击步骤：
1. 攻击者构造出特殊的URL，其中包含恶意代码
2. 用户打开带有恶意代码的URL
3. 用户浏览器接受到响应后解析执行，**前端JavaScript**取出URL中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者执行的操作

与前面两种的区别：DOM型的XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞。

### 6. 攻击的预防

XSS攻击有两大要素：
1. 攻击者提交恶意代码
2. 浏览器执行恶意代码

#### 6.1 输入过滤

输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。

#### 6.2 预防存储型和反射型XSS

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的。预防这两种漏洞有两种常见做法：

1. 改成纯前端渲染，把代码和数据分隔开
2. 对HTML做充分转义

- 纯前端渲染

纯前端渲染过程：
1. 浏览器先加载一个静态HTML，此HTML中不包含任何跟业务相关的数据
2. 然后浏览器执行HTML中的JavaScript
3. JavaScript通过Ajax加载业务数据，调用DOM API更新到页面上、

在纯前端渲染的过程中，我们明确告诉浏览器，下面要设置的是文本、样式还是属性，浏览器不会被轻易欺骗。

但是纯前端渲染还需注意避免DOM型XSS漏洞。如onload事件、href中的JavaScript:xxx等

- 转义HTML

使用转义库，对HTML模板各处充分转义。

#### 6.5 预防DOM型XSS攻击

DOM型XSS攻击实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。

在使用innerHTML、outerHTML、document.write是要特别小心，尽量使用textContent、setAttribute等。

避免使用内联时间监听器，如location、onclick、onerror、onmouseover等。

#### 6.6 其他预防手段

- 输入内容长度控制
- HTTP-only Cookie：禁止JavaScript读取某些敏感Cookie
- 验证码

## CSRF跨站点请求伪造

CSRF跨站请求伪造是一种挟持用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

简单理解为：攻击者可以盗用你的登录信息，以你的身份模拟发送各种请求对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息、盗取你的账号、添加管理员，甚至于购买商品、虚拟货币转账等。

### 1. CSRF原理

1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A
2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A
3. 在用户未退出网站A之前，在同一浏览器中，打开一个TAB也访问网站B
4. 网站B接收到用户请求后，返回一些攻击性代码，并发送一个请求要求访问第三方站点A
5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求，网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理请求，导致来自网站B的而已代码被执行。


CSRF攻击的三个条件：
1. 用户已经登录了站点A，并在本地记录了Cookie
2. 在用户没有登出站点A的情况下（也就是Cookie生效的情况下），访问了恶意攻击者提供的引诱危险站点B（B站点要求访问站点A）
3. 站点A没有做任何CSRF防御

### 2. CSRF攻击防御
可以从服务端和客户端两方面入手，一般从服务端防御进行。

服务端防御思路主要有两个方面：

1. 正确使用GET，POST请求和Cookie
2. 在非GET请求中增加Token并验证

为什么Token可以防御CSRF而Cookie不行？

- 在非GET请求中增加Token并验证
    - 黑客直接利用用户自己的Cookie来通过验证
    - 请求中放入不能伪造的信息，并且该信息不存在于Cookie中，请求中以参数的形式加入随机产生的token，并且在服务端简历一个拦截来验证token
- 检查HTTP Referer字段
- 在HTTP头中自定义属性并验证


## 总结
1. XSS和CSRF是什么
2. XSS和CSRF攻击的特点
3. 如何预防